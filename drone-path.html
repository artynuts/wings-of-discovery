<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <title>Drone Path Planner - The Wings of Discovery</title>
    <style>
      /* Drone Path Planner Specific Styles */
      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .header {
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 40px;
        margin-bottom: 30px;
        text-align: center;
      }

      .header h1 {
        color: #333;
        font-size: 2.5em;
        margin-bottom: 10px;
      }

      .header p {
        color: #666;
        font-size: 1.1em;
      }

      .main-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
      }

      .content {
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 40px;
      }

      .section {
        margin-bottom: 30px;
      }

      .section h2 {
        color: #333;
        margin-bottom: 20px;
        font-size: 1.5em;
      }

      .input-group {
        margin-bottom: 20px;
      }

      .input-group label {
        display: block;
        color: #333;
        font-weight: 600;
        margin-bottom: 8px;
      }

      .input-group input {
        width: 100%;
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-family: "Nunito", sans-serif;
        font-size: 1em;
        transition: border-color 0.3s ease;
      }

      .input-group input:focus {
        outline: none;
        border-color: #8a3edb;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        flex: 1;
        padding: 15px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn-primary {
        background: linear-gradient(135deg, #8a3edb 0%, #4b1f69 100%);
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
      }

      .btn-secondary {
        background: #f0f0f0;
        color: #333;
      }

      .btn-secondary:hover {
        background: #e0e0e0;
      }

      .canvas-container {
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 40px;
        margin-bottom: 30px;
      }

      canvas {
        width: 100%;
        height: auto;
        border: 2px solid #e0e0e0;
        border-radius: 5px;
        display: block;
        cursor: crosshair;
      }

      .results {
        display: none;
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 40px;
      }

      .results.active {
        display: block;
      }

      .result-item {
        background: #f8f9ff;
        padding: 20px;
        border-radius: 10px;
        border-left: 5px solid #8a3edb;
        margin-bottom: 15px;
      }

      .result-label {
        color: #666;
        font-weight: 600;
        margin-bottom: 5px;
        font-size: 0.95em;
      }

      .result-value {
        color: #333;
        font-size: 1.2em;
        font-weight: 700;
      }

      .info-box {
        background: #e3f2fd;
        border-left: 5px solid #8a3edb;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .info-box strong {
        color: #8a3edb;
      }

      .error-message {
        display: none;
        background: #ffebee;
        border-left: 5px solid #e74c3c;
        color: #c0392b;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-weight: 600;
      }

      .error-message.active {
        display: block;
      }

      .step-indicator {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        padding: 15px;
        background: #f8f9ff;
        border-radius: 8px;
      }

      .step-badge {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background: #e0e0e0;
        color: #666;
        font-weight: bold;
        font-size: 0.9em;
      }

      .step-badge.active {
        background: #8a3edb;
        color: white;
      }

      .step-badge.completed {
        background: #4caf50;
        color: white;
      }

      .points-list {
        background: #f8f9ff;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        padding: 15px;
        margin-top: 15px;
      }

      .points-list h3 {
        color: #333;
        font-size: 1.1em;
        margin-bottom: 15px;
      }

      .point-item {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 12px;
        padding: 10px;
        background: white;
        border-radius: 5px;
        border: 1px solid #e0e0e0;
      }

      .point-item input {
        padding: 8px;
        font-size: 0.9em;
      }

      .point-label {
        font-weight: 600;
        color: #666;
        font-size: 0.9em;
        padding: 8px 0;
      }

      @media (max-width: 1024px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 768px) {
        .header h1 {
          font-size: 1.8em;
        }

        .content {
          padding: 20px;
        }

        .button-group {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="back-header">
      <a href="index.html" class="back-button">‚Üê Back to Home</a>
      <div class="wings-branding">
        <img
          src="images/WingsOfDiscovery-Logo.png"
          alt="Wings of Discovery"
          class="wings-logo"
        />
        The Wings of Discovery
      </div>
    </div>
    <div class="container">
      <div class="header">
        <h1>üìç Drone Path Planner</h1>
        <p>Draw a polygon, convert to rectangle, generate coverage path</p>
      </div>

      <div class="main-content">
        <!-- Left Panel: Controls -->
        <div class="content">
          <div class="error-message" id="errorMessage"></div>

          <div class="step-indicator">
            <div class="step-badge completed">1</div>
            <div
              style="flex: 1; display: flex; align-items: center; color: #666"
            >
              Click on canvas to draw polygon
            </div>
          </div>

          <div class="section">
            <h2>Settings</h2>
            <div class="info-box">
              <strong>Instructions:</strong>
              <ul style="margin: 10px 0 0 20px; line-height: 1.8">
                <li>
                  <strong>Left-click</strong> on the canvas to add points and
                  draw a polygon
                </li>
                <li>
                  <strong>Left-click on a point</strong> to delete it (with
                  confirmation)
                </li>
                <li>
                  <strong>Right-click</strong> on the canvas to remove the last
                  point
                </li>
                <li>
                  The rectangle will be calculated automatically from your
                  polygon
                </li>
                <li>
                  Each sector line in the coverage path is 5 feet apart by
                  default
                </li>
                <li>
                  Adjust the scale, speed, and field of view settings as needed
                </li>
              </ul>
            </div>

            <div class="input-group">
              <label for="scale">Scale (feet per pixel):</label>
              <input
                type="number"
                id="scale"
                placeholder="0.1"
                value="0.1"
                min="0.001"
                max="100"
                step="0.1"
              />
            </div>

            <div class="input-group">
              <label for="droneSpeed">Drone Speed (feet/second):</label>
              <input
                type="number"
                id="droneSpeed"
                placeholder="30"
                value="30"
                min="1"
                max="200"
                step="1"
              />
            </div>

            <div class="input-group">
              <label for="droneFOV">Drone FOV (feet between lines):</label>
              <input
                type="number"
                id="droneFOV"
                placeholder="5"
                value="5"
                min="0.5"
                max="100"
                step="0.5"
                onchange="generatePath()"
                oninput="generatePath()"
              />
            </div>

            <div class="points-list" id="pointsList" style="display: none">
              <h3>Point Adjustments</h3>
              <div id="pointsContainer"></div>
            </div>
          </div>

          <div class="button-group">
            <button class="btn-primary" onclick="generatePath()">
              üöÄ Generate Path
            </button>
            <button class="btn-secondary" onclick="clearCanvas()">
              üîÑ Clear
            </button>
            <button
              class="btn-primary"
              id="codeBtn"
              onclick="generateDroneBloxCode()"
              style="display: none"
            >
              üíª Export Code
            </button>
            <button
              class="btn-primary"
              id="blocksBtn"
              onclick="generateDroneBlocksCode()"
              style="display: none"
            >
              üß© Export Blocks
            </button>
          </div>
        </div>

        <!-- Right Panel: Canvas and Results -->
        <div>
          <div class="canvas-container">
            <h2 style="margin-bottom: 20px">Survey Area</h2>
            <canvas id="pathCanvas" width="600" height="600"></canvas>
          </div>

          <div class="results" id="results">
            <h2>Coverage Path Results</h2>
            <div class="result-item">
              <div class="result-label">Rectangle Dimensions:</div>
              <div class="result-value" id="dimensions">0 ft √ó 0 ft</div>
            </div>
            <div class="result-item">
              <div class="result-label">Number of Sectors:</div>
              <div class="result-value" id="numSectors">0</div>
            </div>
            <div class="result-item">
              <div class="result-label">Total Path Length:</div>
              <div class="result-value" id="pathLength">0 ft</div>
            </div>
            <div class="result-item">
              <div class="result-label">Estimated Flight Time:</div>
              <div class="result-value" id="flightTime">0 seconds</div>
            </div>
            <div class="result-item">
              <div class="result-label">Coverage Area:</div>
              <div class="result-value" id="coverageArea">0 sq ft</div>
            </div>
          </div>

          <div class="code-section" id="codeSection" style="display: none">
            <h2>DroneBlox Code</h2>
            <div
              style="
                background: #f5f5f5;
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 15px;
              "
            >
              <textarea
                id="codeOutput"
                style="
                  width: 100%;
                  height: 300px;
                  font-family: monospace;
                  font-size: 12px;
                  padding: 10px;
                  border: 1px solid #ddd;
                  border-radius: 5px;
                  resize: vertical;
                "
              ></textarea>
            </div>
            <button
              class="btn-primary"
              onclick="copyCodeToClipboard()"
              style="width: 100%"
            >
              üìã Copy Code
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("pathCanvas");
      const ctx = canvas.getContext("2d");

      let polygonPoints = [];
      let pathGenerated = false;
      let generatedPath = null;
      let boundingRect = null;
      let draggedPointIndex = -1;
      let pointWasDragged = false;

      canvas.addEventListener("click", (e) => {
        // Don't process click if a point was just dragged
        if (pointWasDragged) {
          pointWasDragged = false;
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Check if clicking on existing point
        let clickedPoint = -1;
        for (let i = 0; i < polygonPoints.length; i++) {
          const dist = Math.sqrt(
            Math.pow(x - polygonPoints[i].x, 2) +
              Math.pow(y - polygonPoints[i].y, 2)
          );
          if (dist < 10) {
            clickedPoint = i;
            break;
          }
        }

        // If clicking on existing point, show delete confirmation
        if (clickedPoint !== -1) {
          const confirmDelete = confirm(`Delete point ${clickedPoint + 1}?`);
          if (confirmDelete) {
            polygonPoints.splice(clickedPoint, 1);
            drawCanvas();
            updatePointsList();
            console.log(`Point ${clickedPoint + 1} deleted`);
          }
        } else {
          // If not clicking on existing point, add new point
          polygonPoints.push({ x, y });
          drawCanvas();
          updatePointsList();
          console.log(`Point ${polygonPoints.length} added`);
        }
      });

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Check if clicking on a point to drag
        for (let i = 0; i < polygonPoints.length; i++) {
          const dist = Math.sqrt(
            Math.pow(x - polygonPoints[i].x, 2) +
              Math.pow(y - polygonPoints[i].y, 2)
          );
          if (dist < 10) {
            draggedPointIndex = i;
            canvas.style.cursor = "grabbing";
            break;
          }
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Check if hovering over a point
        let hovering = false;
        for (let i = 0; i < polygonPoints.length; i++) {
          const dist = Math.sqrt(
            Math.pow(x - polygonPoints[i].x, 2) +
              Math.pow(y - polygonPoints[i].y, 2)
          );
          if (dist < 10) {
            hovering = true;
            break;
          }
        }
        canvas.style.cursor = hovering ? "grab" : "crosshair";

        // Drag point if one is being dragged
        if (draggedPointIndex >= 0) {
          pointWasDragged = true;
          polygonPoints[draggedPointIndex].x = x;
          polygonPoints[draggedPointIndex].y = y;
          drawCanvas();
          updatePointsList();
          if (pathGenerated) {
            generatePath();
          }
        }
      });

      canvas.addEventListener("mouseup", () => {
        draggedPointIndex = -1;
        canvas.style.cursor = "crosshair";
      });

      canvas.addEventListener("mouseleave", () => {
        draggedPointIndex = -1;
        canvas.style.cursor = "crosshair";
      });

      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        if (polygonPoints.length > 0) {
          polygonPoints.pop();
          drawCanvas();
          updatePointsList();
        }
      });

      function drawCanvas() {
        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas
        ctx.fillStyle = "#f8f9ff";
        ctx.fillRect(0, 0, width, height);

        // Draw grid
        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 0.5;
        const gridSize = 50;
        for (let i = 0; i < width; i += gridSize) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, height);
          ctx.stroke();
        }
        for (let i = 0; i < height; i += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(width, i);
          ctx.stroke();
        }

        // Draw polygon
        if (polygonPoints.length > 0) {
          ctx.strokeStyle = "#8A3EDB";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
          for (let i = 1; i < polygonPoints.length; i++) {
            ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
          }
          // Close the polygon by connecting back to the first point
          if (polygonPoints.length > 2) {
            ctx.lineTo(polygonPoints[0].x, polygonPoints[0].y);
          }
          ctx.stroke();

          // Draw distance labels between points
          const scale = parseFloat(document.getElementById("scale").value);
          ctx.fillStyle = "#e74c3c";
          ctx.font = "bold 11px Arial";
          for (let i = 0; i < polygonPoints.length; i++) {
            const curr = polygonPoints[i];
            const next = polygonPoints[(i + 1) % polygonPoints.length];
            const pixelDist = Math.sqrt(
              Math.pow(next.x - curr.x, 2) + Math.pow(next.y - curr.y, 2)
            );
            const feetDist = pixelDist * scale;
            const midX = (curr.x + next.x) / 2;
            const midY = (curr.y + next.y) / 2;
            ctx.fillText(`${feetDist.toFixed(1)} ft`, midX + 5, midY - 5);
          }

          // Draw points
          ctx.fillStyle = "#4B1F69";
          polygonPoints.forEach((p, i) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "#333";
            ctx.font = "bold 12px Arial";
            ctx.fillText(`${i + 1}`, p.x + 10, p.y - 10);
            ctx.fillStyle = "#4B1F69";
          });
        }

        // Draw bounding rectangle
        if (boundingRect) {
          ctx.strokeStyle = "#f39c12";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(
            boundingRect.x,
            boundingRect.y,
            boundingRect.width,
            boundingRect.height
          );
          ctx.setLineDash([]);
        }

        // Draw generated path
        if (generatedPath) {
          ctx.strokeStyle = "#4caf50";
          ctx.lineWidth = 1.5;
          generatedPath.forEach((line) => {
            ctx.beginPath();
            ctx.moveTo(line.x1, line.y1);
            ctx.lineTo(line.x2, line.y2);
            ctx.stroke();
          });
        }
      }

      function updatePointsList() {
        const container = document.getElementById("pointsContainer");
        const pointsList = document.getElementById("pointsList");

        if (polygonPoints.length === 0) {
          pointsList.style.display = "none";
          return;
        }

        pointsList.style.display = "block";
        container.innerHTML = "";
        const scale = parseFloat(document.getElementById("scale").value);

        polygonPoints.forEach((point, index) => {
          // Calculate distance to next point
          const nextPoint = polygonPoints[(index + 1) % polygonPoints.length];
          const pixelDist = Math.sqrt(
            Math.pow(nextPoint.x - point.x, 2) +
              Math.pow(nextPoint.y - point.y, 2)
          );
          const feetDist = pixelDist * scale;

          const pointItem = document.createElement("div");
          pointItem.className = "point-item";
          pointItem.innerHTML = `
            <div style="grid-column: 1 / -1;">
              <div class="point-label">Point ${index + 1} to Point ${
            ((index + 1) % polygonPoints.length) + 1
          }: ${feetDist.toFixed(1)} ft (drag points to adjust)</div>
            </div>
          `;
          container.appendChild(pointItem);
        });
      }

      function calculateBoundingRectangle(points) {
        let minX = points[0].x,
          maxX = points[0].x;
        let minY = points[0].y,
          maxY = points[0].y;

        points.forEach((p) => {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        });

        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
        };
      }

      function generatePath() {
        try {
          const errorMsg = document.getElementById("errorMessage");
          errorMsg.classList.remove("active");

          if (polygonPoints.length < 3) {
            throw new Error("Please draw a polygon with at least 3 points");
          }

          const scale = parseFloat(document.getElementById("scale").value);
          if (scale <= 0) {
            throw new Error("Scale must be greater than 0");
          }

          // Calculate bounding rectangle
          boundingRect = calculateBoundingRectangle(polygonPoints);

          // Generate sector lines (using Drone FOV setting)
          const droneFOV = parseFloat(
            document.getElementById("droneFOV").value
          );
          const sectorSpacingPixels = droneFOV / scale;
          generatedPath = [];

          // Horizontal sectors
          for (
            let x = boundingRect.x + sectorSpacingPixels;
            x < boundingRect.x + boundingRect.width;
            x += sectorSpacingPixels
          ) {
            generatedPath.push({
              x1: x,
              y1: boundingRect.y,
              x2: x,
              y2: boundingRect.y + boundingRect.height,
            });
          }

          // Calculate results
          const rectWidthFt = boundingRect.width * scale;
          const rectHeightFt = boundingRect.height * scale;
          const numSectors = Math.ceil(rectWidthFt / droneFOV) + 1;

          let totalPathLength = 0;
          generatedPath.forEach((line) => {
            const pixelDist = Math.sqrt(
              Math.pow(line.x2 - line.x1, 2) + Math.pow(line.y2 - line.y1, 2)
            );
            totalPathLength += pixelDist * scale;
          });

          const droneSpeed = parseFloat(
            document.getElementById("droneSpeed").value
          );
          const flightTime = Math.ceil(totalPathLength / droneSpeed);
          const coverageAreaSqFt = rectWidthFt * rectHeightFt;

          // Display results
          document.getElementById("dimensions").textContent =
            rectWidthFt.toFixed(1) + " ft √ó " + rectHeightFt.toFixed(1) + " ft";
          document.getElementById("numSectors").textContent = numSectors;
          document.getElementById("pathLength").textContent =
            totalPathLength.toFixed(1) + " ft";
          document.getElementById("flightTime").textContent =
            flightTime + " seconds (" + (flightTime / 60).toFixed(1) + " min)";
          document.getElementById("coverageArea").textContent =
            coverageAreaSqFt.toFixed(1) + " sq ft";

          document.getElementById("results").classList.add("active");
          document.getElementById("codeBtn").style.display = "block";
          document.getElementById("blocksBtn").style.display = "block";
          pathGenerated = true;
          drawCanvas();
        } catch (error) {
          const errorMsg = document.getElementById("errorMessage");
          errorMsg.textContent = "‚ùå " + error.message;
          errorMsg.classList.add("active");
          document.getElementById("results").classList.remove("active");
        }
      }

      function clearCanvas() {
        polygonPoints = [];
        pathGenerated = false;
        generatedPath = null;
        boundingRect = null;
        document.getElementById("results").classList.remove("active");
        document.getElementById("errorMessage").classList.remove("active");
        document.getElementById("pointsList").style.display = "none";
        document.getElementById("codeSection").style.display = "none";
        document.getElementById("codeBtn").style.display = "none";
        document.getElementById("blocksBtn").style.display = "none";
        drawCanvas();
      }

      function generateDroneBloxCode() {
        if (!pathGenerated || !generatedPath || !boundingRect) {
          alert("Please generate a path first!");
          return;
        }

        const scale = parseFloat(document.getElementById("scale").value);
        const droneSpeed = parseFloat(
          document.getElementById("droneSpeed").value
        );

        // Generate JavaScript code for DroneBlox
        let code = `// DroneBlox Coverage Path Code\n`;
        code += `// Generated by Wings of Discovery\n\n`;
        code += `async function executeCoveragePath() {\n`;
        code += `  // Takeoff\n`;
        code += `  await drone.takeoff();\n`;
        code += `  await drone.sleep(2000);\n\n`;

        code += `  // Move to start position\n`;
        code += `  const startX = ${boundingRect.x * scale};\n`;
        code += `  const startY = ${boundingRect.y * scale};\n`;
        code += `  await drone.moveTo(startX, startY, 10);\n\n`;

        code += `  // Execute coverage path\n`;
        code += `  const pathLines = [\n`;

        generatedPath.forEach((line, index) => {
          const x1 = (line.x1 * scale).toFixed(2);
          const y1 = (line.y1 * scale).toFixed(2);
          const x2 = (line.x2 * scale).toFixed(2);
          const y2 = (line.y2 * scale).toFixed(2);
          code += `    { x1: ${x1}, y1: ${y1}, x2: ${x2}, y2: ${y2} }`;
          if (index < generatedPath.length - 1) code += `,`;
          code += `\n`;
        });

        code += `  ];\n\n`;
        code += `  // Fly along each sector line\n`;
        code += `  for (let line of pathLines) {\n`;
        code += `    await drone.moveTo(line.x1, line.y1, 5);\n`;
        code += `    await drone.moveTo(line.x2, line.y2, 5);\n`;
        code += `    await drone.sleep(500);\n`;
        code += `  }\n\n`;
        code += `  // Return to start position\n`;
        code += `  await drone.moveTo(startX, startY, 10);\n`;
        code += `  await drone.sleep(1000);\n\n`;
        code += `  // Land\n`;
        code += `  await drone.land();\n`;
        code += `}\n\n`;
        code += `// Execute the coverage path\n`;
        code += `executeCoveragePath();\n`;

        // Display code
        document.getElementById("codeOutput").value = code;
        document.getElementById("codeSection").style.display = "block";
      }

      function generateDroneBlocksCode() {
        if (!pathGenerated || !generatedPath || !boundingRect) {
          alert("Please generate a path first!");
          return;
        }

        const scale = parseFloat(document.getElementById("scale").value);
        const droneSpeed = parseFloat(
          document.getElementById("droneSpeed").value
        );

        // Generate DroneBlocks XML format (visual blocks)
        let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        xml += `<xml xmlns="https://developers.google.com/blockly/xml">\n`;
        xml += `  <variables></variables>\n`;
        xml += `  <block type="drone_event_launch" id="start" x="20" y="20">\n`;
        xml += `    <next>\n`;
        xml += `      <block type="drone_takeoff">\n`;
        xml += `        <value name="ALTITUDE"><shadow type="math_number"><field name="NUM">2</field></shadow></value>\n`;
        xml += `        <next>\n`;
        xml += `          <block type="drone_move_to_position">\n`;
        xml += `            <value name="X"><shadow type="math_number"><field name="NUM">${(
          boundingRect.x * scale
        ).toFixed(1)}</field></shadow></value>\n`;
        xml += `            <value name="Y"><shadow type="math_number"><field name="NUM">${(
          boundingRect.y * scale
        ).toFixed(1)}</field></shadow></value>\n`;
        xml += `            <value name="Z"><shadow type="math_number"><field name="NUM">10</field></shadow></value>\n`;
        xml += `            <next>\n`;

        // Add loops for each path line
        let loopCount = 0;
        generatedPath.forEach((line, index) => {
          const x1 = (line.x1 * scale).toFixed(1);
          const y1 = (line.y1 * scale).toFixed(1);
          const x2 = (line.x2 * scale).toFixed(1);
          const y2 = (line.y2 * scale).toFixed(1);

          xml += `              <block type="drone_move_to_position">\n`;
          xml += `                <value name="X"><shadow type="math_number"><field name="NUM">${x1}</field></shadow></value>\n`;
          xml += `                <value name="Y"><shadow type="math_number"><field name="NUM">${y1}</field></shadow></value>\n`;
          xml += `                <value name="Z"><shadow type="math_number"><field name="NUM">5</field></shadow></value>\n`;
          xml += `                <next>\n`;
          xml += `                  <block type="drone_move_to_position">\n`;
          xml += `                    <value name="X"><shadow type="math_number"><field name="NUM">${x2}</field></shadow></value>\n`;
          xml += `                    <value name="Y"><shadow type="math_number"><field name="NUM">${y2}</field></shadow></value>\n`;
          xml += `                    <value name="Z"><shadow type="math_number"><field name="NUM">5</field></shadow></value>\n`;
          xml += `                    <next>\n`;
          xml += `                      <block type="drone_delay">\n`;
          xml += `                        <value name="MILLISECONDS"><shadow type="math_number"><field name="NUM">500</field></shadow></value>\n`;
          xml += `                        <next>\n`;
          loopCount++;
        });

        // Close all the nested blocks
        for (let i = 0; i < loopCount; i++) {
          xml += `                        </next>\n`;
          xml += `                      </block>\n`;
          xml += `                    </next>\n`;
          xml += `                  </block>\n`;
          xml += `                </next>\n`;
          xml += `              </block>\n`;
        }

        xml += `                        </next>\n`;
        xml += `                      </block>\n`;
        xml += `                      <block type="drone_move_to_position">\n`;
        xml += `                        <value name="X"><shadow type="math_number"><field name="NUM">${(
          boundingRect.x * scale
        ).toFixed(1)}</field></shadow></value>\n`;
        xml += `                        <value name="Y"><shadow type="math_number"><field name="NUM">${(
          boundingRect.y * scale
        ).toFixed(1)}</field></shadow></value>\n`;
        xml += `                        <value name="Z"><shadow type="math_number"><field name="NUM">10</field></shadow></value>\n`;
        xml += `                        <next>\n`;
        xml += `                          <block type="drone_land">\n`;
        xml += `                          </block>\n`;
        xml += `                        </next>\n`;
        xml += `                      </block>\n`;
        xml += `            </next>\n`;
        xml += `          </block>\n`;
        xml += `        </next>\n`;
        xml += `      </block>\n`;
        xml += `    </next>\n`;
        xml += `  </block>\n`;
        xml += `</xml>\n`;

        // Display code
        document.getElementById("codeOutput").value = xml;
        document.getElementById("codeSection").style.display = "block";
      }

      function copyCodeToClipboard() {
        const codeOutput = document.getElementById("codeOutput");
        codeOutput.select();
        document.execCommand("copy");
        alert("Code copied to clipboard!");
      }

      // Initial draw
      drawCanvas();
    </script>
  </body>
</html>
